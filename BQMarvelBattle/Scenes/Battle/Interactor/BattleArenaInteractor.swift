//
//  BattleArenaInteractor.swift
//  BQMarvelBattle
//
//  Created by Tarsha de Souza on 9/5/20.
//  Copyright (c) 2020 Tarsha de Souza. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import ObjectMapper

protocol RankingsGeneralProtocol {
    func retrieveFromJsonFile(fileUrl: URL, completion: @escaping ([Character]?, Error?) -> [Character]?) -> [Character]?
}

protocol BattleArenaBusinessLogic {
    func determineWinner(request: BattleArena.Model.Request)
}

protocol BattleArenaDataStore {
    var BattleSummary: [Character]? { get }
}

class BattleArenaInteractor: BattleArenaBusinessLogic, BattleArenaDataStore {
    var presenter: BattleArenaPresentationLogic?
    var repository: Repository?
    var BattleSummary: [Character]?
    
    func determineWinner(request: BattleArena.Model.Request) {
        let winner = calculateWinner(fighters: request.fighters)
        let response = BattleArena.Model.Response(winner: winner)
        presenter?.presentWinner(response: response)
    }
    
    func calculateWinner(fighters: [Character]) -> Character {
        BattleSummary = writeAndReadToFile(fighters: fighters)
        let sortedArray = fighters.sorted {(a, b) -> Bool in
            guard let fighterA = a.comics?.available, let fighterB = b.comics?.available else {
                return false
            }
            return fighterA > fighterB
        }
        return sortedArray.first ?? Character()
    }
    
    func writeAndReadToFile(fighters: [Character]) -> ([Character]?) {
        guard let documentDirectoryUrl = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {
            return (nil)
        }
        let fileUrl = documentDirectoryUrl.appendingPathComponent("BattleChallenges.json")
        let fileExists = (try? fileUrl.checkResourceIsReachable()) ?? false
        if !fileExists {
            //if its the first time lets write to it-
            let initialArray = self.createNewArrayToSave(currentFighters: fighters)
            writeToFile(fighters: initialArray, toFile: fileUrl)
        }

        // Write to new json with previous values included
        //Read previous JSON
        let _ = retrieveFromJsonFile(fileUrl: fileUrl) { (battlesArray, error)  in
            if error != nil {
                return (nil)
            }
            
            //Compare the two or merge the two so there are no duplicates
            let progressiveBattlesArray = self.createNewArrayToSave(previousBattlesArray: battlesArray, currentFighters: fighters)
            //Write to new progressive JSON
            self.writeToFile(fighters: progressiveBattlesArray, toFile: fileUrl)
            return (battlesArray)
        }
        
        // Read the new file && get the array
         let finalBattleArray = retrieveFromJsonFile(fileUrl: fileUrl) { (currentBattleArray, error) in
            if error != nil {
                return (nil)
            }
            return (currentBattleArray)
        }
        
        return (finalBattleArray)
    }
    
    func createNewArrayToSave(previousBattlesArray: [Character]? = nil, currentFighters: [Character]) -> [String : [[String : Any]]] {
        if let previousBattles = previousBattlesArray {
            let finalBattlesArray = Array(Set(currentFighters + previousBattles))
            return ["results": finalBattlesArray.toJSON()]
        } else {
            return ["results": currentFighters.toJSON()]
        }
    }
    
    func writeToFile(fighters: [String : [[String : Any]]], toFile fileUrl: URL) {
        do {
            let data = try JSONSerialization.data(withJSONObject: fighters, options: [])
            try data.write(to: fileUrl, options: [])
        } catch {
            print(AppError.customError(description: "BattleInteractor-writeToFile(): Error thrown line 99."))
        }
    }
}

extension BattleArenaInteractor: RankingsGeneralProtocol {
    func retrieveFromJsonFile(fileUrl: URL, completion: @escaping ([Character]?, Error?) -> [Character]?) -> [Character]? {
        var battlesArray = [Character]()
        // Read data from .json file and transform data into an array
        do {
            let data = try Data(contentsOf: fileUrl, options: [])
            guard let results = try JSONSerialization.jsonObject(with: data, options: []) as? NSDictionary else {
                return completion(nil, AppError.resourceLoadingError)
            }
            
            if let fighters = results["results"] as? Array<Dictionary<String,AnyObject>> {
                fighters.forEach { fighter in
                    guard let character = Mapper<Character>().map(JSON: fighter) else {
                        return
                    }
                    battlesArray.append(character)
                }
            }
            return completion(battlesArray, nil)
        } catch {
            return completion(nil, AppError.resourceLoadingError)
        }
    }
}
